/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.10 Man7.glb 
*/

import React, { useEffect, useRef, useCallback, useState } from 'react'
import { useGLTF, useAnimations, useTexture, useEnvironment, useHelper, Sparkles } from '@react-three/drei'
import { useFrame, useThree } from '@react-three/fiber'
import { EffectComposer, SSAO, Bloom, DotScreen } from "@react-three/postprocessing";
import MainNoise  from './Noise';
import { useSpring, animated } from '@react-spring/three';
import { useGesture, useWheel, useScroll } from '@use-gesture/react'


export function Man(props) {
  const group = useRef()
  const dotRef = useRef()
  const composerRef = useRef()
  console.log(dotRef)
  const { nodes, materials, animations } = useGLTF('/Man7.glb')
  const { actions } = useAnimations(animations, group)
  const colorMap = useTexture('/Textures/colorTextureBW.jpg');
  const noise = useTexture('/Textures/noise.jpeg');
  const manEnvironemt = useEnvironment({files: '/Textures/New-Project-_1_.hdr'})
  // const envMap = useTexture('/Textures/colorTexture.hdr');
  console.log(actions)
  // const [color, setColor] = useState([0.0,0.65,1.0])
  const [color, setColor] = useState([1.0,1.0,1.0])
  const [newPos, setNewPos] = useState([])
  const [newRot, setNewRot] = useState(0)
  
  function mapToRange(value, fromLow, fromHigh, toLow, toHigh) {
    let result = ((value - fromLow) * (toHigh - toLow)) / (fromHigh - fromLow) + toLow;
    if(result < 0){
      result-=0.5
    }
    return result/6
  }

  const [springs, api] = useSpring(()=>({
    rotationY: 0,
    glow: 0,
    position: [0,-3,2],
    color: [0.0,0.65,1.0],
    config: ()=>{
      return { mass: 10, friction: 60 }
    }
  }))

  const handleMouseMove = useCallback(e=>{
    const windowWidth = window.screen.availWidth
    // console.log(e.clientX)
    // console.log(((event.clientX/windowWidth) -0.5)/4)
    // group.current.rotation.y = mapToRange(event.clientX, 0, windowWidth, -2, 1)
    // api.start({
    //   rotationY: mapToRange(e.clientX, 0, windowWidth, -0.5, 0.5),
    // })
    // Canvas.camera.position.x=Math.sin(event.clientX)
  },[api])

  var wheelOffset = 0
  
  const WheelHandler = useCallback((event) => {
    wheelOffset += 0.005 * event.delta[1];
    let currentScrollPos = window.scrollY;
    const screenHeight = window.innerHeight;
    // console.log(event.delta[1], wheelOffset, currentScrollPos, screenHeight);
  
    if (currentScrollPos > 0 && currentScrollPos <= screenHeight) {
      // Animation for the first section
      console.log("First section")
      let curSpringPos = springs.position.get()
      let curSpringRot = springs.rotationY.get()
      api.start({
        position: [wheelOffset / 22, -3 - wheelOffset / 22, 3 + wheelOffset / 12],
        rotationY: -wheelOffset / 4,
      });
      setNewPos([wheelOffset / 22, -3 - wheelOffset / 22, 3 + wheelOffset / 12])
      setNewRot(-wheelOffset / 4)
      // setColor([1.0,1.0,1.0])
    } else if (currentScrollPos > screenHeight && currentScrollPos <= screenHeight * 2) {
      // Animation for the second section
      console.log("Second section")
      let curSpringPos = springs.position.get()
      let curSpringRot = springs.rotationY.get()
      console.log(curSpringPos, curSpringRot)
      // group.current.children[0].children[1].children[1].material.userData.shader.uniforms.uColor.value = [0,0.65,1];
      api.start({
        position: [wheelOffset / 22, -3 - wheelOffset / 22, 3 + wheelOffset / 12],
        rotationY: -wheelOffset/4,
      });
      // setColor([1.0,0.65,1.0])
    } else if (currentScrollPos > screenHeight * 2 && currentScrollPos <= screenHeight*4.8) {
      // Animation for the third section
      console.log("Third section")
      let curSpringPos = springs.position.get()
      let curSpringRot = springs.rotationY.get()
      console.log(curSpringPos, curSpringRot)
      // api.start({
      //   position: [curSpringPos[0]-0.01, curSpringPos[1]-0.01, curSpringPos[2]-0.5,],
      //   rotationY: curSpringRot + 0.1,
      // });
      api.start({
        position: [0.2+wheelOffset*0.001, -3-wheelOffset*0.005, 1.5+wheelOffset*0.1],
        rotationY: -2+wheelOffset*0.05,
      });
      // setColor([0.2,0.4,0.2])
    }
    else if (currentScrollPos > screenHeight * 4.8 && currentScrollPos <= screenHeight*7.5){
      console.log("fourth Section")
      let curSpringPos = springs.position.get()
      let curSpringRot = springs.rotationY.get()
      console.log(curSpringPos, curSpringRot)
      // actions.ArmatureGlobal.time = 40;
      // actions.ArmatureGlobal.paused = false;
      // actions.ArmatureGlobal.play()
      // console.log(actions.ArmatureGlobal)
      api.start({
        position: [0.4+wheelOffset*0.01, -3+wheelOffset*0.01, 2+wheelOffset*0.01],
      });
    }
    else if (currentScrollPos > screenHeight * 7.5 && currentScrollPos <= screenHeight*9){
      console.log("fifth section")
      let curSpringPos = springs.position.get()
      let curSpringRot = springs.rotationY.get()
      console.log(curSpringPos, curSpringRot)
      // actions.ArmatureGlobal.time = 40;
      // actions.ArmatureGlobal.paused = false;
      // actions.ArmatureGlobal.play()
      // console.log(actions.ArmatureGlobal)
      api.start({
        position: [0.05+wheelOffset*0.04, -3, wheelOffset*0.03],
        rotationY: -0.5,
      });
    }
  }, [api]);

  // const WheelHandler = (e)=>{
  //   console.log(e)
  //   // e.preventDefault()
  // }

  const bod = document.body
  useScroll(WheelHandler, { target: window})
  // useWheel(WheelHandler, { target: window })
  
  
  
  useEffect(()=>{
    window.addEventListener('pointermove', handleMouseMove)
    return ()=>{
      window.removeEventListener('pointermove', handleMouseMove)
    }
  }, [handleMouseMove])

  
  const onBeforeCompile = (shader) => {
    console.log(shader)
    shader.uniforms.uTime = {value: 0}
    shader.uniforms.uColor = {value: [0, 0.65, 1]}
    shader.fragmentShader = `
      uniform float uTime;
      mat4 rotationMatrix(vec3 axis, float angle) {
        axis = normalize(axis);
        float s = sin(angle);
        float c = cos(angle);
        float oc = 1.0 - c;
        
        return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                    0.0,                                0.0,                                0.0,                                1.0);
    }
    
    vec3 rotate(vec3 v, vec3 axis, float angle) {
      mat4 m = rotationMatrix(axis, angle);
      return (m * vec4(v, 1.0)).xyz;
    }
    ` + shader.fragmentShader;
    shader.fragmentShader = shader.fragmentShader.replace(
      `#include <envmap_physical_pars_fragment>`,
      `#ifdef USE_ENVMAP

      vec3 getIBLIrradiance( const in vec3 normal ) {
    
        #ifdef ENVMAP_TYPE_CUBE_UV
          vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
    
          vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
    
          return PI * envMapColor.rgb * envMapIntensity;
    
        #else
    
          return vec3( 0.0 );
    
        #endif
    
      }
    
      vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
    
        #ifdef ENVMAP_TYPE_CUBE_UV
    
          vec3 reflectVec = reflect( - viewDir, normal );
    
          // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
          reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
    
          reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
    
          reflectVec = rotate(reflectVec, vec3(1.0, 0.0, 0.0), uTime * 0.5);
          vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
    
          return envMapColor.rgb * envMapIntensity;
    
        #else
    
          return vec3( 0.0 );
    
        #endif
    
      }
    
      #ifdef USE_ANISOTROPY
    
        vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
    
          #ifdef ENVMAP_TYPE_CUBE_UV
    
            // https://google.github.io/filament/Filament.md.html#lighting/imagebasedlights/anisotropy
            vec3 bentNormal = cross( bitangent, viewDir );
            bentNormal = normalize( cross( bentNormal, bitangent ) );
            bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
    
            return getIBLRadiance( viewDir, bentNormal, roughness );
    
          #else
    
            return vec3( 0.0 );
    
          #endif
    
        }
    
      #endif
    
    #endif`
      )

    
    group.current.children[0].children[1].children[1].material.userData.shader = shader;
    // shader.vertexShader = shader.vertexShader.replace(
    //   '#include <project_vertex>',
    //   `
    //   gl_Position = projectionMatrix * modelViewMatrix * vec4(position * 2.0, 1.0);
    // `
    // )

  }

  useEffect(()=>{
    console.log(group.current.children[0].children[1].children[1].material.userData)
    // group.current.children[0].children[1].children[1].material.userData.shader.uniforms = {}
    // group.current.children[0].children[1].children[1].material.userData.shader.uniforms.uColor = {}
    // group.current.children[0].children[1].children[1].material.userData.shader.uniforms.uColor.value = [0,0.65,1];
    // group.current.children[0].children[1].children[1].material.map = colorMap;
    // group.current.children[0].children[1].children[1].material.metalnessMap = noise;
    group.current.children[0].children[1].children[1].material.metalness = 0.9;
    group.current.children[0].children[1].children[1].material.roughness = 0.4;
    group.current.children[0].children[1].children[1].material.envMap = manEnvironemt;
    group.current.children[0].children[1].children[1].material.envMapIntensity = 0.1;
    group.current.children[0].children[1].children[1].material.onBeforeCompile = onBeforeCompile
    group.current.children[0].children[1].children[1].material.toneMapped = false
    
    for (var key in actions) {
      if (actions.hasOwnProperty(key)) {
        let t = key.replace(".","")
        actions[t] = actions[key]
        // console.log(actions[key]); // 'hello'
      }
    }
    // window.addEventListener("mousemove", handleMouseMove)
    
    // actions.ArmatureGlobal._interpolantSettings.endingStart = 1267;
    // actions.ArmatureGlobal._interpolantSettings.endingEnd = 1267;
    console.log("stared")

    // actions.ArmatureGlobal.time = 27;

    // Update the animation mixer to apply the changes
    actions.ArmatureGlobal.play()
    console.log(actions)
    setTimeout(()=>{
      console.log("Paused")
      actions.ArmatureGlobal.paused = true;
    }, 10000)
    console.log(actions.ArmatureGlobal)
  },[])
  
  useFrame(({clock})=>{
    // console.log(group.current.children[0].children[1].children[1].material.userData)
    group.current.rotationY += 1;
    if(group.current.children[0].children[1].children[1].material.userData.shader){
      let time = clock.getElapsedTime()
      group.current.children[0].children[1].children[1].material.userData.shader.uniforms.uTime.value = time
      // group.current.children[0].children[1].children[1].material.userData.shader.uniforms.uColor.value = [0,0.65,1];
      
    }
  })

 
  // console.log(group.current.children[0].children[1].children[1].material)
  

  // springs.color.to((x, y, z) => {
  //   // Update the color value
  //   console.log(dotRef)
  //   // dotRef.current.material.uniforms.color.value.set(x, y, z);
  // });
  return (
    <>
      
      {/* <Sparkles size={3} scale={20} count={500} color="#EFEFEF"/> */}
      {/* <Sparkles size={3} scale={20} count={500} color="#6431b5"/> */}
      <group>
        <EffectComposer smaa ref={composerRef}>
              {/* <DotScreen ref={dotRef}/> */}
              <MainNoise ref={dotRef} {...props} color={color}/>
              <Bloom intensity={1} luminanceSmoothing={0.22} mipmapBlur luminanceThreshold={2}/>
              {/* <SSAO /> */}
        </EffectComposer>
        <animated.group ref={group} {...props} rotation={springs.rotationY.to((x)=>[-Math.PI*0.05,x,0])} dispose={null} position={springs.position.to((x,y,z)=>[x,y,z])}>
          <group name="Scene">
            <group name="BezierCurve" position={[-1.466, -1.593, 1.107]} scale={0.906} />
            <group name="Armature">
              <primitive object={nodes.spine}/>
              <skinnedMesh name="Man" geometry={nodes.Man.geometry} material={nodes.Man.material} skeleton={nodes.Man.skeleton} />
            </group>
          </group>
        </animated.group>
      </group>
    </>
  )
}

useGLTF.preload('/Man7.glb')
